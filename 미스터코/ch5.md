## 나는 이 책에서 무엇을 얻어가고 싶을까?
- 어떻게 공부하면 좋을까?
- 무엇이 궁금할까?
- 어떤 좋은 표현들이 있는가?
- 저자는 독자가 무엇을 알기를 원할까

> 스프링이 개발자에게 제공하는 가장 중요한 가치가 무엇이냐고 질문한다면 나는 주저하지 않고 객체지향과 __테스트__ 라고 대답할 것이다. <sup id="a1">[1](#f1)</sup>

# 5장 서비스 추상화...!

> '이 부분을 추상화해보는 것은 어떨까요?' - 화투

### 앗... 추상화가 무엇인가요??...
- 기술등에 상관없이 '기능과 목적'이 유사한 기술들을 동일한 방식으로 사용할 수 있도록

예시를 통해서 알려주고 싶었던 부분??
- 레벨을 다루는 로직
- 모든 유저들에 관한
    - 트랜잭션
        - db 업데이트
        - 메일 전송

## 5.1 사용자 레벨 관리 기능 추가
### 5.1.1 필드 추가
- Enum 의 사용
    - 명시적으로 내가 사용할 상수만 사용할 수 있도록 강제적으로 제한 (ex. int를 사용할 경우 내가 원치 않는 값도 주고 받을 수 있음)
- User 의 필드 추가
- UserDaoTest 수정
    - 변경된 필드에 맞게 수정 (이 부분이 놓치면.. 테스트가 올바르지않는 테스트가 됨. 확인을 못하는 부분이 생기기에)
- UserDao 수정
    - Sql 쿼리 수정
        - 컴파일 과정에서는 검증할 수 없는 부분
        - 그렇기에 테스트가 존재해야 함 (실제 서버로 올리기 전에 빠르게 알 수 있음)

### 5.1.2 사용자 수정 기능 추가
> id 를 제외한 User 의 정보들은 여러번 수정 될 수 있음
- 수정 기능 테스트
- UserDao 와 UserDaoJdbc 에 기능 추가 (update)
- 수정 테스트 보완
    - Sql 쿼리가 가장 실수 하기 쉬운 부분..!
        - ex. where 절 빼먹는 경우
        - 원하는 로우 (해당 id 를 사용하는) 만 변경 되었는지 확인
            - 리턴값을 통한 (반환 받은 수정된 로우의 갯수를 확인)
            - 테스트 데이터를 통한 확인 (2개 이상의 데이터를 놓고 1개만 변경되었는지 확인)
    - 귀찮다고 대충 작성한 테스트는 오히려 찾기 힘든 버그와 사고의 원인..!

### 5.1.3 UserService.upgradeLevels()
    - 사용자 관리 로직은 어디에 두는게 좋을까요? (비즈니스 로직 서비스..!)
    - UserDao 의 구현 클래스가 바뀌어도 영향받지 않도록
- UserService 클래스와 빈 등록
    - userDao 빈을 DI 받도록
- UserServicetTest
- upgradeLevels() 
    - 모든 유저를 살펴본다
        - 각 유저마다 바꿀 것인지 확인
        - 바꿔야하는 경우 db에서 변경
- upgradeLevels() 테스트..!
    - 모든 경우에 대한 검즘
        - 3가지 레벨중에 업그레이드 가능한 레벨이 2가지
            - 따라서 총 5가지의 경우의 수가 존재 (3가지 레벨 변화 없는 경우 + 2가지 레벨 업그레이드 되는 경우)

### 5.1.4 UserService.add() 
- 처음 가입하는 User 는 기본적으로 BASIC 레벨
    - 이 로직은 어디로 가야 좋을까용??
    - 비지니스 로직인데..
        - UserDaoJdbc? -> 이 친구는 User 오브젝트를 DB에 넣고 읽는 곳에만 관심을 가져야 함
        - User 클래스에서 초기화? -> 처음 가입할 때만 사용할 것인데... 꼭 여기서 해야하나?
        - UserService..! -> 사용자관리에 대한 비즈니스 로직을 담고 있기에
            - 사용자가 등록될 때 적용할 만한 비즈니스 로직을 담당하도록
            - 역시나 테스트 구현하자..! (레벨이 비어있는 상태로 추가되면 Level.BASIC 사용하는지)

### 5.1.5 코드 개선
```
작성된 코드를 살펴볼 때에 해볼법한 질문들
- 코드에 중복된 부분은 없는가?
- 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
- 코드가 자신이 있어야 할 자리에 있는가?
- 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고, 그 변화에 수비게 대응할 수 있게 작성되어 있는가?
```
- upgradeLevels() 의 문제점
    - 성격이 다른 로직들이 한데 섞여 있음...
- upgradelevels() 리팩토링
    - 가장 먼저 추상적인 레벨에서 로직을 작성
        - 현재는 자주 변경될 가능성이 있는 구체적인 내용이 __추상적인 로직__ 의 흐름과 함께 섞여 있음
        - 구체적인 구현에서 외부에 노출할 인터페이스를 분리하듯
```java
public void upgradeLevels() {
    List<User> users = userDao.getAll();
    for(User user : users) {
        if (canUpgradeLevel(user)) { // 상태에 따른 업그레이드 조건
            upgradeLevel(user);      // 업그레이드 적용
        }
    }
}
```
    - 다음 레벨을 결정하는 것은 Level에게 맡기기
        - 각 레벨은 다음 레벨의 정보를 가지고 있음
        - 다름 레벨정보를 Level에게 요청하도록 (다음레벨을 알아내는 것을 위임)
```java
private void upgradeLevel(User user) {
    user.upgradeLevel();            // user 에게 위임..! (user 는 Level 에게 위임...ㅎ)
    userDao.update(user);
}
```
> UserService, User, Level 이 내부 정보를 다루는 자신의 책임에 충실한 기능을 갖고 있으면서 필요가 생기면 이런 작업을 수행해달라고 서로 요청하는 구조 (자기 책임만 다루기에 이해하기 쉬움, 변경이 필요할 때 어디를 수정해야 할지 찾기 쉬움)

- UserTest
    - 역시나 모든 LEVEL 에 대하여 검증 (모든 경우의 수를 검증)
- UserServiceTest
    - LEVEL 의 구체적인 값을 몰라도 되도록 수정
        - LEVEL 이 추가되어도 코드 변경이 필요 없도록
    - 테스트하려는 것이 바로 표현되도록
> 한 가지 변경 이유가 발생했을 때 여러 군데를 고치게 만든다면 __중복__  

- UserLevelUpgradePolicy 를 통해서 UserService 에서 해당 로직을 분리 할 수도 있음
    - 특정 이벤트 일 때, 레벨 정책이 바뀔 수 있는 경우

## 5.2 트랜잭션 서비스 추상화
### 5.2.1 모 아니면 도
- 테스트용 UserService 대역
    - 내가 원할 때 예외를 던질 수 있었으면... (그래야 트랜잭션이 되는지 테스트하지)
    - ex. 내가 변경하고 싶은 애를 상속받고 내가 원하는 결과를 리턴하도록 오버라이드..! (간단한 스텁)
- 강제 예외 발생을 통한 테스트
    - 테스트에서만 사용할 것들
        - 테스트를 위한 예외 클래스
### 5.2.2 트랜잭션 결계설정
- JDBC 트랜잭션의 트랜잭션 경계 설정
    - 시작위치
    - 끝위치
        - 롤백 (모두 취소)
        - 커밋 (모두 DB에 적용)
    - Connection 을 사용
- UserService 와 UserDao 의 트랜잭션 문제
    - Connection 을 건들 수가 없다...
    - 각 User 에 대한 부분이 각각의 트랜잭션으로 적용되기 때문...
        - DAO 클래스에서 DB 커넥션을 매번 만듬
- 비즈니스 로직 내의 트랜잭션 경계설정
    - UserService 와 UserDao 를 그대로 둔 채로 트랜잭션을 적용하려면?
    - 트랜잭션 경계설정 작업을 UserService 쪽으로 가져와야 함..
        - connection 을 계속 넘겨 주어야 함...
- UserService 트랜잭션 경계설정의 문제점
    - UserService 에서 JDBC API 를 직접 사용했던 초기방식으로 돌아감
        - 다시 중복 문제가 생김... 매 Service 마다 똑같이 구현할래??..ㅠ
    - 파라미터를 통해 connection 을 계속 전달해야함
        - userService 가 싱글톤객체기에(공유되기에) ... 해당 connection을 상태로 저장해 놓을 수가 없음
    - UserDao 인터페이스에 connection 이 추가되면 데이터 엑세스 기술에 독립일 수 없음
        - JDBC 로직이기에...
### 5.2.3 트랜잭션 동기화 (에공.. 어떻게 자기가 사용할 connection을 알아낼 수 있을까? 스레드마다 저장한다는데... 해당 스레드가 다른 일로 넘어가도 괜찮은건가??)
- Connection 파라미터 제거
    - JdbcTemplate 에서 자기가 사용할 커넥션을 가져온다 (없으면 안에서 생성)
    - rollback() 시에도 동기화된 connection을 제거해 주어야함
> 트랜잭션 동기화 저장소는 작업 스레드마다 독립적으로 connection 오브젝트를 저장하고 관리하기에 다중 사용자를 처리하는 서버의 멀티스레드 환경에서도 충돌이 날 염려는 없다. 

### 트랜잭션 서비스 추상화
- 기술과 환경에 종속되는 트랜잭션 경계설정 코드
    - 다른 기술을 적용해서 트랜잭션을 사용한다면?..!
- 트랜잭션 API 의 의존관계 문제와 해결책
    - 추상화란 하위 시스템의 공통점을 뽑아내서 분리시키는 것
    - 하위시스템을 몰라도, 바뀌어도 __일관된__ 방법으로 접근 가능해짐
- 스프링의 트랜잭션 서비스 추상화
- 트랜잭션 기술 설정의 분리

> 어떤 클래스든 스프링의 빈으로 등록할 때 먼저 검토해야 할 것은 싱글톤으로 만들어져 여러 스레드에서 동시에 사용해도 괜찮은가 하는 점이다.  

> ... UserService 의 코드는 조금도 수정할 필요가 없다..! (이것이 목표가 되어야 하는가..?!)

## 5.3 서비스 추상화와 단일 책임 원칙
- 수직, 수평 계층 구조와 의존관계
    - 수평적인 분리: 내용에 따른 분리
    - 수직적인 분리: 다른 계층과의 분리 (ex. 비즈니스 로직과 로우 레벨 트랜잭션의 기술)

## 5.4 

### 테스트 대역(test double)
- 스텁 (stub)
    - 필요한 정보를 대체하기 위한 역할
        - 테스트 내부에 의존된 애들로 부터 얻고 싶은 정보들 (입력)
- 목 (mock)
    - 테스트 오브젝트와 자신(목) 사이에서 일어나는 커뮤니케이션을 저장, 검증
        - 메소드 호출 (올바른 매개변수, 호출 되었는지)

### ???
트랜잭션 동기화 저장소

### 참조
> <b id="f1"><sup>1</sup></b> 우리가 읽고있는 토비경이 쓴 책에서 나옴 뜻함.[↩](#a1)<br> 