# 1.4 제어의 역전(IoC)
## 1.4.1 오브젝트 팩토리(factory)
- 팩토리: 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 반환하는 오브젝트
> 여기서 말하는 팩토리와 특별한 문제를 해결하는 추상 팩토리 패턴이나 팩토리 메소드 패턴과는 다르니 혼동하지 말자.

### 팩토리 메소드 패턴
팩토리 메소드 패턴은 자식클래스에서 구체적인 오브젝트 생성 방법을 결정하는 패턴이다. 그러므로 부모클래스는 자식클래스에서 어떤 것을 생성하는지 신경쓰지 않는다.

- 부모클래스(슈퍼클래스)

```java
public abstract class UserDao {
  public void add(User user) throws ClassNotFoundException, SQLException {
    Connection c = getConnection();
    // ...
  }

  public User get(String id) throws ClassNotFoundException, SQLException {
    Connection c = getConnection();
    // ...
  }

  // 메서드 구현은 자식클래스가 담당한다.
  public abstract Connection getConnection() throws ClassNotFoundException, SQLException;
}
```

- 자식클래스(서브클래스)

```java
public class NUserDao extends UserDao {
  public Connection getConnection() throws ClassNotFoundException, SQLException {
    // N 사 DB connection 생성코드
  }
}
```

```java
public class DUserDao extends UserDao {
  public Connection getConnection() throws ClassNotFoundException, SQLException {
    // D 사 DB connection 생성코드
  }
}
```

<그림 1.2>

위 코드는 추상 메서드가 오브젝트를 생성하므로 팩토리 메소드 패턴이기도 하지만, 크게 보면 **템플릿 메소드 패턴** 이다. 템플릿 메소드 패턴은
- 부모클래스에 기본적인 로직의 흐름(커넥션 가져오기, SQL 생성, 실행, 반환 등)을 만들고, **그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드** 등으로 만든 뒤 자식클래스에서 해당 메소드를 구현하는 방법
이다.

다시 팩토리로 돌아와서,

- 팩토리는 단지 오브젝트를 생성하는 쪽과 사용하는 쪽의 역할과 책임을 분리하기 위함이다.

```java
// UserDao의 생성 책임을 맡은 팩토리 클래스
public class DaoFactory {
  public UserDao userDao() {
    // 팩토리의 메소드는 UserDao 타입의 오브젝트를 어떻게 만들고, 어떻게 준비시킬지를 결정한다.
    ConnectionMaker connectionMaker = new DConnectionMaker();
    UserDao userDao = new UserDao(connectionMaker);
    return userDao;
  }
}
```

### 설계도로서의 팩토리
- 컴포넌트: 실질적인 로직을 담당하는 부분
  - 예제에서 ```UserDao```, ```ConnectionMaker```와 같은 클래스
- 설계도: 컴포넌트의 구조와 관계를 정의
  - 예제에서 ```DaoFactory```와 같은 클래스

<그림 1.8>

팩토리를 분리했을 때 가장 큰 장점은
  - 애플리케이션의 컴포넌트 역할과
  - 애플리케이션의 구조를 결정하는 오브젝트를
분리하였다는 것이다.

## 1.4.2 오브젝트 팩토리의 활용
- ```DaoFactory```에서 여러 DAO의 생성 기능을 넣는다면 다음과 같은 코드가 나올 것이다.

```java
public class DaoFactory {
  public UserDao userDao() {
    return new UserDao(new DConnectionMaker());
  }

  public UserDao accountDao() {
    return new accountDao(new DConnectionMaker());
  }

  public UserDao messageDao() {
    return new messageDao(new DConnectionMaker());
  }
}
```

위 코드의 문제점은 ```new DConnectionMaker()```이 계속 반복되는 것이다.
- 이러한 중복 문제를 해결하는 가장 간단한 방법은 메소드로 분리하는 것이다.

```java
public class DaoFactory {
  public UserDao userDao() {
    return new UserDao(connectionMaker());
  }

  public UserDao accountDao() {
    return new accountDao(connectionMaker());
  }

  public UserDao messageDao() {
    return new messageDao(connectionMaker());
  }

  // 중복을 제거한 메소드
  public ConnectionMaker connectionMaker() {
    return new DConnectionMaker();
  }
}
```

## 1.4.3 제어권 이전을 통한 제어관계 역전
제어의 역전은 간단히 프로그램의 제어 흐름 구조가 뒤바뀌는 것이다.
현재 ```UserDao``` 구조는
- 자신이 사용하는 ```ConnectionMaker```의 구현 클래스(ex, DConnectionMaker)를 자신이 결정하고,
- 그 오브젝트를 필요한 시점에서 생성해두고,

각 메소드에서 이를 사용한다. 이는 대부분 ```main()```도 이와 같으며,

- 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고,
- 언제 어떻게 그 오브젝트를 만들지를 스스로 관장한다.

모든 종류의 작업을 **사용하는 쪽** 에서 제어하는 구조다. 제어의 역전이란, 위의 제어 흐름의 개념을 거꾸로 뒤집는 것이다.

- 즉, **오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다.**
- 생성하지도 않고, 어떻게 만들어지는지 알 수도 없다.

대신, 이를 제어하는 권한을 위임받는 특별한 오브젝트가 있어야 한다.

- 보통 프로그램 시작을 담당하는 ```main()```과 같은 엔트리 포인트에서 이를 수행함.

제어의 역전은 프로그래밍에서 굉장히 많이 사용하는 방법이다.

- 서블릿이나 JSP, EJB처럼 컨테니어 안에서 동작하는 구조
- 템플릿 메소드 패턴
- 프레임워크

### 프레임워크 VS 라이브러리
- 라이브러리: 미리 만들어두거나 확장에서 사용할 수 있도록 준비된 추상된 코드 집합
  - 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 **직접 제어한다.**
- 프레임워크
  - 라이브러리와 반대로 애플리케이션 코드가 **프레임의크에 의해 사용된다.**
  - 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하는 방식
  - 프레임워크는 제어의 역전 개념이 있어야 한다.
  - 애플리케이션 코드는 프레임워크가 짜 놓은 틀에서 수동적으로 동작한다.

다시 돌아가서,

현재 ```UserDao```와 ```DaoFactory``` 역시 제어의 역전 개념이 도입되었다.

- 더이상 ```UserDao```는 ```ConnectionMaker```에 대한 제어권을 가지고 있지 않고,
- ```DaoFactory```에 제어권을 넘긴 수동적인 상태이다.

IoC(제어의 역전)를 적용하면
- 유연성이 증가하며
- 확장성이 좋아진다.

스프링은 IoC를 극한까지 적용하고 있는 프레임워크로 쉽게 IoC를 적용할 수 있도록 도와준다.

# 1.5 스프링의 IoC
스프링의 핵식을 담당하는 것은

- 빈 팩토리
- 애플리케이션 컨텍스트

이다. 이 두 가지는 이전에 만든 ```DaoFactory```가 하는 일을 좀 더 일반화한 것이다.

## 1.5.1 오브젝트 팩토리를 이용한 스프링 IoC
스프링에서 빈은

- 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 말한다.
- [자바빈](https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94%EB%B9%88%EC%A6%88) 또는 [엔터프라이즈 자바빈(EJB)](https://ko.wikipedia.org/wiki/엔터프라이즈_자바빈즈)에서 말하는 빈과 비슷한 오브젝트 단위의 애플리케이션 컴포넌트

- 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트

빈 팩토리는

- 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트

말한다. 하지만 보통 빈 팩토리보다는 이를 좀 더 확장한 애플리케이션 컨텍스트를 주로 사용한다.

- 애플리케이션 컨텍스트는 IoC 방식을 따라 만들어진 일종의 빈 팩토리

애플리케이션 컨텍스트와 빈 팩토리는 동일하다고 생각할 수 있다. 둘의 차이점은 단순히

- 빈 팩토리는 빈을 생성하고 관계를 설정하는 IoC의 기본 기능에 초점을 맞춘 것이고,
- 애플리케이션 컨텍스트는 애플리케이션 전반에 걸쳐 모든 구성요소의 제어를 직접 담당하는 IoC엔진
  - 별도의 정보를 참고해서 빈의 생성, 관계설정 등의 제어 작업을 총괄

여기서 별도의 정보라는 것은 이전에 살펴본 설계도를 말한다.

### ```DaoFactory```를 사용하는 애플리케이션 컨텍스트

```java
@Configuration
public class DaoFactory {
  @Bean
  public UserDao userDao() {
    return new UserDao(connectionMaker());
  }

  @Bean
  public ConnectionMaker connectionMake() {
    return new DConnectionMaker();
  }
}
```

- ```@Configuration```: 애플리케이션 컨텍스트 또는 빈 팩토리가 사용할 설정정보라는 표시
- ```@Bean```: 오브젝트 생성을 담당하는 IoC용 메소드라는 표시

이제 위의 설정정보를 사용하는 애플리케이션 컨텍스트를 만들어보자.

```java
public class UserDaoTest {
  public static void main(String[] args) throws ClassNotFoundException, SQLException {
    ApplicationContext context =
      new AnnotationConfigApplicationContext(DaoFactory.class);
      UserDao dao = context.getBean("userDao", UserDao.class);
  }
}
```

- ```AnnotationConfigApplicationContext()```: ```@Configuration```이 붙은 자바 코드를 설정정보로 사용한다.
- ```getBean(메서드 이름, 클래스)```: 애플리케이션 컨텐스트가 관리하는 오브젝트를 요청하는 메서드
  - 해당 메서드는 기본적으로 Object타입을 리턴하여 다시 캐스팅하는 부담이 있었지만, 자바 5이상의 제네릭을 사용하여 이를 해결함

## 1.5.2 애플리케이션 컨텍스트의 동작방식
오브젝트 팩토리에 대응되는 것이 애플리케이션 컨텍스트이다. 이는 간단히 IoC 컨테이너라고도 부른다.

- 애플리케이션 컨텍스트는 ```ApplicationContext``` 인터페이스를 구현하고, 이는 ```BeanFactory``` 인터페이스를 상속한다.
- 즉, 애플리케이션 컨텍스트는 빈 팩토리의 일종이다.

<그림 1.9>

### 애플리케이션 컨텐스트의 장점
오브젝트 팩토리로 직접 사용했을 때와 비교했을 때, 애플리케이션 컨텍스트의 장점은 다음과 같다.

- 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다. => 한 번 더 생각해 볼것
- 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
- 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.

## 1.5.3 스프링 IoC의 용어 정리
- 빈(또는 빈 오브젝트): 스프링이 IoC 방식으로 관리하는 오브젝트로, 스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 말한다.
- 빈 팩토리: 스프링의 IoC를 담당하는 핵심 컨테이너로 빈의 등록, 생성, 조회, 등 빈을 관리하는 역할을 담당한다. 보통 빈 팩토리를 바로 사용하기 보단 애플리케이션 컨텍스트를 이용한다.
- 애플리케이션 컨텍스트: 빈 팩토리를 확장한 것으로 기본적인 빈 팩토리와 기능은 동일하고 이에 더해 스프링이 제공하는 각종 부가 서비스를 제공한다.
  - 빈 팩토리는 주로 빈의 생성과 제어의 관점을 말하고,
  - 애플리케이션 컨텍스트는 스프링이 제공하는 애플리케이션 지원 기능을 모두 포함함
- 설정정보/설정 메타정보: 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보
- 컨테이너 또는 IoC 컨테이너: 애플리케이션 컨텍스트와 빈 팩토리와 동일하게 불리기도 하며, 애플리케이션 컨텍스트보다 추상적인 개념이라고 볼 수 있다.

# 1.6 싱글톤 레지스트리와 오브젝트 스코프
애플리케이션 컨텍스트는 오브젝트 팩토리와 중요한 차이점이 있다.
- 오브젝트 팩토리에서 만든 두 오브젝트는 동일하지 않다.
- 애플리케이션 컨텍스트가 만든 두 오브젝트는 동일하다.

> 오브젝트의 동일성과 동등성
> 자바는 두 개의 오브젝트가 같은가라는 말을 두 가지로 나눈다.
> - 두 개의 오브젝트가 완전히 같은 동일한(identical) 오브젝트
> 이는 동일성(identity) 비교라고 하고, == 연산자로 판단한다.
> - 두 개의 오브젝트가 동일한 정보를 담고 있는(equivalent) 오브젝트
> 이는 동등성(equality) 비교라고 하고, equals() 메소드를 이용하여 판단한다.
> 자바에서 동일성은 레퍼런스 주소로 판단하고, 동등성은 해당 오브젝트 필드의 값이 같은 지로 판단한다. 그러브로 동등하다고 해서 동일하지는 않는다.
> 자바는 클래스에서 equals() 메소드를 구현하지 않으면 기본적으로 동일성을 비교한다.

애플리케이션 컨텍스트가 만든 두 오브젝트가 동일하다는 것은 레퍼런스 주소가 같다는 것이고, 이는 **싱글톤** 패턴이 적용되었다는 것을 알 수 있다.

## 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다. 애플리케이션 컨텍스트는 싱글톤으로 저장하고 관리하는 싱글톤 레지스트리 기능도 가지고 있다.

- 여기서 싱글톤이라는 것은 싱글톤 패턴과 비슷한 개념이지만 그 구현 방법은 확연히 다르다.

스프링이 싱글톤으로 빈을 만드는 이유는 스프링이 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 **서버환경** 이기 때문이다.

- 서버는 기본적으로 요청이 매우 많다.
- 이러한 많은 요청 마다 새로운 오브젝트를 만드는 것은 매우 비효율적이다.

서버 환경에서 싱글톤 패턴은 큰 장점을 가지고 있지만, 싱글톤 패턴을 사용하기에는 한계가 많다.

### 싱글톤 패턴의 한계

```java
public class UserDao {
  private static UserDao INSTANCE;
  // ...
  private UserDao(ConnectionMaker connectionMaker) {
    this.connectionMaker = connectionMaker;
  }
  public static synchronized UserDao getInstance() {
    if (INSTANCE == null) INSTANCE = new UserDao(???);
    return INSTANCE;
  }
  // ...
}
```

- private 생성자를 갖고 있기 때문에 상속할 수 없다.
- 싱글톤은 테스트하기 힘들다.

싱글톤은 사용할 오브젝트를 다이내믹하게 주입하기 힘들기 때문에 직접 오브젝트를 만들어야 하는데, 테스트에서 프로덕션과 다른 오브젝트를 만들지 못한다.

- 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
- 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.
- 코드가 지저분해진다.

### 싱글톤 레지스트리
싱글톤 레지스트리는 public 생성자를 사용할 수 있고, static 메소드를 사용할 필요가 없다. 단지 일반적인 클래스와 같이 만들 수 있으므로, 객체지향적으로 사용할 수 있다.

## 1.6.2 싱글톤과 오브젝트의 상태
이제부터는 싱글톤으로 만들어지기 때문에 주의해야할 점에 대해 알아보자.

- 싱글톤은 멀티스레드 환경에서 여러 스레드가 접근할 수 있으므로 **상태 관리에** 주의를 기울여야 한다.
- 기본적으로 서비스 오브젝트는 멀티스레드 환경에서 **무상태 방식** 으로 만들어야 한다.

다수의 사용자가 하나의 인스턴스를 동시에 바꾸려고 한다면 매우 위험하기 때문이다. 하지만 단순히 읽기전용 변수가 있는 것은 관계없다.

- 각 요청에 대한 정보를 **파라미터와 로컬 변수, 리턴 값** 등을 이용할 수 있다.

기존의 ```UserDao```클래스에서 ```connectionMaker``` 변수는 읽기 전용이므로 이는 상태 변수로 남아있을 수 있다.(단순한 읽기 전용 변수는 ```static final```이나 ```final```로 선언하자.)

## 1.6.3 스프링 빈의 스코프
빈의 스코프는 빈이 생성되고, 존재하고, 적용되는 범위를 말한다.

- 스프링의 기본 스코프는 싱글톤 스코프이다.

싱글톤 스코프는 컨테이너 내에 한 개로 만들어져 강제로 제거하지 않는 이상 계속 유지된다. 하지만 경우에 따라서 싱글콘 이외의 스코프를 가질 수 있다.

- 프로토타입 스코프는 빈을 요청할 때마다 새로운 오브젝트를 만든다.
- 요청 스코프는 HTTP 요청이 생길때 마다 오브젝트를 만든다.

# 의존관계 주입(DI)
## 1.7.1 제어의 역전과 의존관계 주입
IoC는 매우 느슨하게 정의되어 있는 있고 폭넓게 사용되는 용어이므로 IoC 컨테이너로가만으로는 스프링을 설명하기 힘들다.

- DI는 IoC 방식의 핵심을 짚어주는 용어다.
- IoC컨테이너를 DI 컨테이너라고도 불린다.

> 의존관계 주입, 의존성 주입, 의존 오브젝트 주입
> - 의존성 주입은 DI를 부르는 가장 흔한 용어이지만 이를 설명하기는 부족하다.
> - 의존 오브젝트 주입은 단순히 동작 방식을 말하는 것이고, 정확하지 않다. DI은 엄밀히 말해서 외부 오브젝트 레퍼런스를 전달하여 다이내믹하게 의존관계를 만드는 것이다.
> - 의존관계 주입이 현재로서는 가장 적합한 용어라고 볼 수 있다.

## 1.7.2 런타임 의존관계 설정
A가 B에 의존한다는 것을 그림으로 표현하면 아래와 같다.

<그림 1-10>

위 의존관계에서 의존한다는 건 의존대상, 여기서는 B가 변하면 그것이 A에 영향을 미친다는 것이다. A클래스에 B의 메소드나 B 그 자체가 있는 경우 A가 B에 의존한다고 볼 수 있다.

- 의존 관계에는 방향성이 있다.

기존 예제에서 ```UserDao```는 ```ConnectionMaker```에 의존하고 있는 형태이다. 정확히 말하면 ```ConnectionMaker``` 인터페이스에 의존하고 있으므로 이를 구현한 ```DConnectionMaker``` 클래스가 변경된다해도 ```UserDao``` 클래스에는 영향이 없다.

<그림 1-11>

이와 같이 인터페이스에 의존관계를 두면

- 관계가 느슨해지면서 변화에 영향을 덜 받는다.
- 이를 결합도가 낮다고 한다.

위 그림에서 설계 모델 관점에서 나타나는 의존관계와 달리 런타임 시에 오브젝트 사이에서 만들어지는 의존관계가 있다.

- 이를 런타임 의존관계라고 하며, 위의 모델링 시점의 의존관계와는 성격이 다르다.

여기서 ```UserDao```실제 사용하는 ```DConnectionMaker```은 프로그램이 시작하고 나서 알 수 있으므로 런타임 시에 의존관계를 맺는다.

- 이러한 오브젝트, 즉 실제 사용대상인 오브젝트를 **의존 오브젝트** 라고 한다.

의존관계 주입은

- 구체적인 의존 오브젝트와 그것을 사용할 주체(보통 클라이언트라고 부르는 오브젝트)를 런타임시에 연결해주는 작업을 말한다.

정리하면, 의존관계 주입이란 다음과 같은 세 가지 조건을 충족하는 작업을 말한다.

- 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 **인터페이스** 에만 의존하고 있어야 한다.
  - ```ConnectionMaker```
- 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 **제3의 존재가** 결졍한다.
  - ```DaoFactory```
- 의존관계는 사용할 오브젝트에 대한 **레퍼런스를** 외부에서 제공(주입)해줌으로써 만들어진다.
  - ```DConnectionMaker```

## 1.7.3 의존관계 검색과 주입
의존관계 검색은

- 외부로부터 주입이 아닌 스스로 검색을 이용하는 방법을 말한다.
- 자신이 필요한 오브젝트를 능동적으로 찾는다.
- 물론 자신이 어떤 클래스의 오브젝트를 이용할지는 결정하지 않는다.
- 오브젝트 결정과 해당 오브젝트 생성은 IoC로 외부 컨테이너에 맡기지만, **가져올 때는 스스로 컨테이너에 요청한다.**

```java
public UserDao() {
  DaoFactory daoFactory = new DaoFactory();
  this.connectionMaker = daoFactory.conectionMaker();
}
```

위와 같이 구현하여도 ```UserDao```는 자신이 어떤 오브젝트를 가질지는 스스로 알지 못한다.

- 스프링의 IoC 컨테이너인 애플리케이션 컨텍스트는 ```getBean()```으로 의존관계 검색을 제공한다.

```java
public UserDao() {
  AnnotationConfigApplicationContext context =
    new AnnotationConfigApplicationContext(DaoFactory.class);
  this.connectionMaker = context.getBean("connectionMaker", ConnectionMaker.class);
}
```

- 의존관계 주입이 검색보다 훨씬 코드에서는 간단하다.
- 하지만 의존관계 검색은 프로그램을 시작하고나서 한 번은 사용해야 하는 방법이다.
- 의존관계 검색 방식에서는 검색하는 오브젝트(```UserDao```)는 스프링의 빈일 필요가 없다.
- 반면에 의존관계 주입 방식은 DI를 적용하려는 **두 오브젝트 모두 스프링의 빈이어야 한다.**
  - ```UserDao```에 ```ConnectionMaker``` 오브젝트를 주입해주러면 ```UserDao```에 대한 생성과 초기화 권한이 필요하다.

## 1.7.5 메소드를 이용한 의존관계 주입
생성자가 아닌 일반 메소드를 이용해 의존 오브젝트와의 관계를 주입해주는 방법은 크게 두 가지가 있다.

- 수정자 메소드(```setter```)를 이용한 주입
- 일반 메소드를 이용한 주입
  - ```setter```와 달리 여러 개의 파라미터를 가질 수 있다.

# 2장 테스트
- 스프링 프레임워크를 사용한데 테스트는 매우 매우 중요하다.
- 스프링 프레임워크 또한 테스트 기반하여 구현하였다.
- 테스트를 위해 필요한 프레임워크(Juit)를 잘 사용해야한다.
- 테스트는 작은 단위테스트부터 하는 것이 좋다.
- 테스트는 자신의 코드에 자신감을 준다.
- TDD는 매우 매력적이므로 그냥 하자.

## 질문 목록
- p100
  - 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다는데 현재, main()이 클라이언트라고 생각하면 직접 클래스를 알아야하는데 잘 이해가 되지 않음
  - 인터셉팅은 인터셉터의 의미인가?
