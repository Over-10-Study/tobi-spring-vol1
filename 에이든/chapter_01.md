# Chapter 01 - 오브젝트와 의존관계

> **스프링의 철학**은 자바 엔터프라이즈 기술의 혼란 속에서 잃어버렸던 객체지향 기술의 진정한 가치를 회복하고, 그로부터 **객체지향 프로그래밍이 제공하는 폭넓은 혜택을 누릴 수 있도록 기본으로 돌아가는 것이다.**
> 그래서, 관심을 많이 두는 대상은 **오브젝트**다. 애플리케이션에서 **오브젝트가 생성**되고 **다른 오브젝트와 관계를 맺고**, **오브젝트가 사용**되고, **오브젝트가 소멸**하기까지의 전 과정을 진지하게 생각해볼 필요가 있다.

## 1.1 초난감 DAO
> **DAO**
> DAO(Data Access Object) 는 DB를 상용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.

> **자바 빈 == 빈**
> 자바빈은 원래 비주얼 툴에서 조작 가능한 컴포넌트를 말한다. 그러나 이제는 두 가지관례를 따라 만들어진 오브젝트를 말한다.
>  * 디폴트 생성자: 파라미터가 없는 생성자
>  * 프로퍼티: 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다.

## 1.2 DAO의 분리
> 객체지향의 세계에서는 모든 것이 변한다. 여기서 변한다는 것은 변수나 오브젝트 필드의 값이 변한다는 게 아니다. **오브젝트에 대한 설계와 이를 구현한 코드가 변한다는 뜻이다.**

> **관심사의 분리**
> 관심이 같은 것 끼리 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것이라고 생각할 수 있다.
> 관심의 종류에 따라 코드를 구분해 놓았기 때문에 한 가지 관심에 대한 변경이 일어날 경우 그 관심이 집중되는 부분의 코드만 수정하면 된다.

### 1.2.3 DB 커넥션 만들기의 독립
* 상속을 통한 확장

![enter image description here](https://lh3.googleusercontent.com/jk-boHKVcFSVONUwdluBYCgi0iwn6E3e7mV8EKTrjWqvhSVE0s7AHkFHX-xXmP_nUBTQhdoRwlc)

* 어떻게 데이터를 등록하고 가져올 것인가(**UserDao**), DB 연결 방법을 어떻게 할 것인가(**NUserDao, DUserDao**)라는 관심을 구분하고 있다.
* 기능을 추상메소드나, 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤, **서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법**을 **탬플릿 메소드 패턴** 이라고 한다.
* UserDao의 서브클래스의 getConnetcion() 메소드는 어떤 Connection 클래스의 오브젝트를 어떻게 생성할 것인지를 결정 하는 방법이다. 이렇게 **서브 클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것**을 **팩토리 메소드 패턴**이라고 한다.

> 여기서 문제는 다른 DAO 클래스에 DB 커넥션을 생성하는 코드를 적용 할 수 없다. 만약 UserDao 외의 DAO클래스들이 계속 만들어진다면 그때는 상속을 통해서 만들어진 getConnection()의 구현 코드가 매 DAO 클래스마다 중복돼서 나타는 심각한 문제가 발생할 것이다.

## 1.3 DAO의 확장
> 모든 오브젝트가 다 동일한 방식으로 변하는 건 아니다. 관심사에 따라서 분리한 오브젝트들은 제각기 독특한 변화의 특징이 있다. 지금 까지 데이터 액세스 로직을 어떻게 만들 것인가와  DB 연결을 어떤 방법으로 할 것인가라는 두 개의 관심을 상하위 클래스로 분리시켰다. 이 두개의 관심은 변화의 성격이 다르다. **변화의 성격이 다르다는 건 변화의 이유와 시기, 주기 등이 다르다는 뜻이다.**

### 1.3.1 클래스의 분리
![enter image description here](https://lh3.googleusercontent.com/a96jYWVHAtUKMRKxzoZRxmO6LrG97kxvqoApp5AhuJhLYvUF85jBpB1BebnQR3qAICRllTT7_Dc)

* 첫 번째 문제는, N 사와 D 사에 UserDao 클래스만 공급하고 상속을 통해 DB 커넥션 기능을 확장해서 사용하게 했던 게 다시 불가능해졌다. 왜냐하면, UserDao의 코드가 SimpleConnectionMaker 라는 특정 클래스에 종속되어 있끼 때문에 상속을 사용했을 때 처럼 UserDao코드의 수정없이 DB 커넥션 생성 기능을 변경할 방법이 없다.
* 두 번째 문제는,  DB 커넥션을 제공하는 클래스가 어떤 것인지를 UserDao가 구체적으로 알고 있어야 한다는 점이다. UserDao에 SimpleConnectionMaker라는 클래스 타입의 인스턴스 변수까지 정의해놓고 있으니, N 사에서 다른 클래스를 구현하면 어쩔 수 없이 UserDao자체를 다시 수정해야한다.

> 근본적인 원인은 UserDao가 바뀔 수 있는 정보, 즉 DB 커넥션을 가져오는 클래스에 대해 너무 많이 알고 있기 때문이다. 어떤 클래스가 쓰일지, 그 클래스에서 커넥션을 가져오는 메소드는 이름이 뭔지까지 일일이 알고 있어야 한다.

### 1.3.2 인터페이스의 도입
> 가장 좋은 해결책은 두 개의 클래스가 서로 긴밀하게 연결 되어 있지 않도록 중간에 추상적인 느슨한 연결고리를 만들어주는 것이다. 추상화란 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업이다. **자바가 추상화를 위해 제공하는 가장 유용한 도구는 바로 인터페이스이다.**

![enter image description here](https://lh3.googleusercontent.com/Gktkl8az2_MyHZnyEN8e02B7WSp91c63dd9-PzglOqBemb4WG7pQWVqct5PHSutAWM18sUE1Fww)

* 인터페이스는 어떤 일을 하겠다는 기능만 정의해놓은 것이다. 따라서 인터페이스에는 어떻게 하겠다는 구현 방법은 나타나 있지 않다. 그것은 인터페이스를 구현한 클래스들이 알아서 결정할 일이다.

![enter image description here](https://lh3.googleusercontent.com/k2cNYbfxem21gv7M9fLvR0PQT1SU-XhW_iNMVjlTJUBAdcfqmp4zAPeobNz8oDlj_5I8_tTfIRQ)
* 그러나 초기에 한 번 어떤 클래스의 오브젝트를 사용할지를 결정하는 생성자의 코드는 제거되지 않고 남아있다.
* 이 때문에 인터페이스를 이용한 분리에도 불구하고 여전히 UserDao 변경 없이는 DB 커넥션 기능의 확장이 자유롭지 못하다.
* UserDao 오브젝트가 다른 오브젝트와 관계를 맺으려면 관계를 맺을 오브젝트가 있어야한다. 이 오브젝트를 꼭 UserDao의 코드 내에서 만들 필요는 없다. 오브젝트는 얼마든지 메소드 파라미터 등을 이용해 전달할 수 있으니 외부에서 만든걸 가져올 수도 있다.

![enter image description here](https://lh3.googleusercontent.com/PqrSX7QEpurebGXfquAOiiXTkyBeYsY2w7FuzkilO0TbMMhgfQDrs-B2UzzNjiM4MW8s1BNn3NY)
* 런타임 오브젝트 관계를 갖는 구조로 만들어주는게 바로 클라이언트의 책임이다.
* 현재는 UserDaoTest는 UserDao와 ConnectionMaker 구현 클래스와의 런타임 오브젝트 의존관계를 설정하는 책임을 담당해야한다.
* 앞에서 사용했던 상속을 통한 확장 방법보다 더 깔끔하고 유연한 방법으로 UserDao와 ConnectionMaker 클래스들을 분리하고 서로 영향을 주지 않으면서도 필요에 따라 자유롭게 확장할 수 있는 구조가 됐다.

### 1.3.4 원칙과 패턴
* 개방 폐쇄 원칙
* 객체지향 설계 원칙(**SOLID**)
	* SRP(The Single Responsibility) 단일 책임 원칙
	* OCP(The Open Closed Principle) 계방 폐쇄 원칙
	* LSP(The Liskov Substitution Principle) 리스코프 치환 원칙
	* ISP(The Interface Segregation Principle) 인터페이스 분리 원칙
	* DIP(The Dependency Inversion Principle) 의존관계 역전 원칙
* 높은 응집도와 낮은 결합도
* 전략 패턴

#### 개방 폐쇄 원칙
* 클래스나 모듈은 확장에는 열려 있어야하고 변경에는 닫혀있어야 한다.
* **UserDao는 DB 연결 방법이라는 기능을 확장하는 데는 열려 있다.** UserDao에 전혀 영향을 주지 않고도 얼마든지 기능을 확장할 수 있게 되었다.
* 동시에 **UserDao 자신의 핵심기능을 구현한 코드는 그런 변화에 영향을 받지 않고 유지**할 수 있으므로 변경에는 닫혀있다.
* 이말을 정리하면, 인터페이스를 통해 제공되는 확장 포인트는 확장을 위해 활짝 개방되어있다. 반면, 인터페이스를 이용하는 클래스는 자신의 변화가 불필요하게 일어나지 않도록 굳게 폐쇄되어 있다.

### 높은 응집도
* 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다.
* 응집도가 높다는 것은 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것으로 설명할 수도 있다. 즉, 변경이 일어날 때 모듈의 많은 부분이 함께 바뀐다면 응집도가 높다고 말할 수 있다.

###  낮은 결합도
* **결합도**란 '**하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도**'라고 말할 수 있다.
* **낮은 결합도**란 결국, 하나의 변경이 발생할 때 마치 파문이 이는 것처럼 **여타 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태**를 말한다.

### 전략패턴
* **자신의 기능 맥락**(**Context**)에서, 필요에 따라 **변경이 필요한 알고리즘을 인터페이스**를 통해 통째로 외부로 분리시키고, 이를 **구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용**할 수 있게 하는 디자인 패턴이다.
* 독립적인 책임으로 분리가 가능한 기능을 대체 가능한 전략이라고 보기 때문에 패턴의 이름이 전략패턴이다.
* UserDao(컨텍스트)는 변경 가능한 DB 연결 방식이라는 알고리즘을 ConnectionMaker라는 인터페이스로 정의하고, 이를 구현한 클래스, 즉 전략을 바꿔가면서 사용할 수 있게 분리했다.

> **스프링이란, 객체지향의 설계 원칙과 디자인 패턴에 나타난 장점을 자연스럽게 개발자들이 활용할 수 있게 해주는 프레임 워크다.**

## 1.4 제어의 역전(IoC)
> 제어의 역전 IoC(Inversion of Control)

### 1.4.1 오브젝트 팩토리
* UserDaoTest는 2가지의 책임을 갖고 있다.
	* 테스트 기능
	* 어떤 ConnectionMaker 구현 클래스를 사용할지를 결정
* 리팩토링이 필요하다.

> 팩토리(factory)
> * 객체 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 일을 하는 오브젝트이다.
> * 단지, 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리하려는 목적으로 사용하는 것이다. 어떻게 만들지 어떻게 사용할지는 다른 관심이다.
> * 특별한 문제를 해결하기 위해 사용되는 추상팩토리 패턴이나 팩토리 메소드 패턴과는 다르다.
> * 팩토리 메소드는 오브젝트를 어떻게 생성할지를 다룬다.

```java
public class DaoFactory {
	public UserDao userDao() {
		ConnectionMaker connectionMaker = new DConnetcionMaker();
		UserDao userDao = new UserDao(connectionMaker);
		return userDao;
	}
}
```
![enter image description here](https://lh3.googleusercontent.com/_0qnhRPFT0uRqBwuLhUht-KPQcaETkg6ur4t4jokHpsficJGre8ZbdMcuMxc5LYWqYJi5dlpjrU)
* DataFactory의 역할과 책임
	* 애플리케이션의 오브젝트들을 구성
	* 오브젝트들의 관계를 정의
* 결국 이런 작업이 애플리케이션 전체에 걸쳐 일어난다면 컴포넌트의 의존관계에 대한 설계도와 같은 역할을 할 것이다.

### 1.4.2 오브젝트 팩토리의 활용
> 만약, 다른 DAO들이 생성된다면...
> 메소드마다 ConnectionMaker 구현 클래스의 오브젝트를 생성하는 코드가 메소드마다 반복될 것이다.
```java
public class DaoFactory {
	public UserDao userDao() {
		ConnectionMaker connectionMaker = new DConnetcionMaker();
		UserDao userDao = new UserDao(connectionMaker);
		return userDao;
	}
	
	public AccountDao accountDao() {
		ConnectionMaker connectionMaker = new DConnetcionMaker();
		AccountDao accountDao= new AccountDao(connectionMaker);
		return accountDao;
	}

	public MessageDao messageDao() {
		ConnectionMaker connectionMaker = new DConnetcionMaker();
		MessageDao messageDao= new MessageDao(connectionMaker);
		return messageDao;
	}
}
```

* ConnectionMaker 의 구현클래스를 결정하고 오브젝트를 만드는 코드를 별도의 메소드로 뽑아내자.
```java
public class DaoFactory {
	public UserDao userDao() {
		return UserDao(connectionMaker());
	}
	
	public AccountDao accountDao() {
		return AccountDao(connectionMaker());
	}

	public MessageDao messageDao() {
		return MessageDao(connectionMaker());
	}

	public ConnectionMaker connectionMaker() {
		return new DConnetcionMaker();
	}
}
```

### 1.4.3 제어권의 이전을 통한 제어관계 역전
> 일반적으로 프로그램의 흐름은 main() 메소드와 같이 프로그램이 시작되는 지점에서 **다음에 사용할 오브젝트를 결정**하고, 결정한 오브젝트를 생성하고, **만들어진 오브젝트에 있는 메소드를 호출**하고, **그 오브젝트 메소드 안에서 다음에 사용할 것을 결정하고 호출하는 식의 작업이 반복**된다.

* 오브젝트의 제어는 스스로 했다.
	* 오브젝트는 자신이 사용할 구현클래스를 자신이 결정했다.
	* 오브젝트를 필요한 시점에서 생성하고, 각 메소드에서 이를 사용한다.
	* 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정한다.
	* 언제 어떻게 그 오브젝트를 만들지를 스스로 관장한다.

* 그런데 이런 제어의 흐름을 꺼꾸로 뒤집는 것이다.
	* 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다.
	* 오브젝트를 당연히 생성하지 않는다.
	* 자신이 어떻게 만들어지고 어디서 사용되는지를 알 수 없다.
	* 모든 오브젝트는 위임받은 제어 권한을 갖는 특별한 오브젝트에 의해 결정되고 만들어진다.

* 제어의 역전의 예시(서블릿)
	* 서블릿을 개발해서 배포할 수 는 있지만, 실행을 개발자가 직접 제어할 수 있는 방법은 없다.
	* 서블릿 안에 main() 메소드가 있어서 직접 실행 시킬 수 있는 것도 아니다.
	* **서블릿에 대한 제어 권한을 가진 컨테이너**가 **적절한 시점에 서블릿 클래스의 오브젝트를 만들**고 **그 안에 메소드를 호출**한다.
* 제어의 역저의 예시(추상클래스를 이용한 UserDao)
	* 추상 UserDao를 상속받은 서브클래스는 getConnection() 을 구현한다.
	* 그러나, 기능만 구현했을 뿐, 언제 어떻게 사용될지는 서브클래스는 모른다.
	* 슈퍼클래스인 UserDao의 템플릿 메소드들이 필요할 때 호출되어서 사용될 뿐이다.

> 라이브러리 VS 프레임 워크
> * 라이브러리는 동작 하는 중에 필요한 기능이 있을 애플리케이션 코드에서 라이브러리를 사용한다.
> * 프레임 워크는 애플리케이션 코드가 프레임워크에 의해서 사용된다.
> * **라이브러리: 애플리케이션이 라이브러리를 사용한다.**
> * **프레임워크: 프레임 워크가 애플리케이션코드를 사용한다.**

내 코드가 수동적으로 작동되니까 답답했구나...

* 제어의 역전에서는 프레임워크 또는 컨테이너와 같이 애플리케이션 **컴포넌트의 생성**과 **관계 설정**, **사용**, **생명주기 관리** 등을 관장하는 존재가 필요하다.

## 1.5 스프링의 IoC
> 빈팩토리, 애플리케이션 컨텍스트라고 불리는 것을 알아보자.

### 1.5.1 오브젝트 팩토리를 이용한 스프링 IoC
* 빈(Bean)
	* 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트
	* 자바빈 또는 엔터프라이즈 자바빈 에서 말하는 빈과 비슷한 오브젝트 단위의 애플리케이션 컴포넌트를 말한다.
	* 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트를 가리키는 말이다.

* 빈 팩토리(bean factory)
	* 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트
	* 이를 좀더 확장한 애플리케이션 컨텍스트를 주로 사용한다.
* 빈 팩토리 VS 애플리케이션 컨텍스트

| 빈 팩토리 | 애플리케이션 컨텍스트 |
|--|--|
| 빈을 생성하고 관계를 설정하는 IoC기본 기능에 초점  | 애플리케이션 전반에 걸쳐 모든구성요소의 제어작업을 담당하는 IoC 엔진에 초점 |

* @Configuration
	* 스프링이 빈팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식하도록 한다.
* @Bean
	* 오브젝트를 만들어주는 메소드에 붙인다.

### 1.5.2 애플리케이션 컨텍스트의 동작방식
![enter image description here](https://lh3.googleusercontent.com/WsvpicO3e5QOG5oUJzWf2RX-HW22hh_rIOT0JAXotbgRiy3CwZOzrwWX1KPLfu9h_ktslhKTJdI)
* 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
* 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해 준다.
* 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.

### 1.5.3 스프링 IoC의 용어 정리
* 빈(Bean)
	* 스프링이 IoC 방식으로 관리하는 오브젝트라는 뜻이다.
	* 스프링을 사용하는 애플리케이션에서 만들어지는 모든 오브젝트가 다 빈은 아니다.
	* 스프링이 직접 그 생성과 제어를 담당하는 오브젝트만 빈이다.
* 빈 팩토리(Bean Factory)
	* 스프링의 IoC를 담당하는 핵심 컨테이너를 가리킨다.
	* 빈을 등록, 빈을 생성, 빈을 조회하고 돌려주고, 그외의 부가적인 빈을 관리한다.
	* 보통은 빈 팩토리를 바로 사용하지 않고 이를 확장한 애플리케이션 컨텍스트를 이용한다.
* 애플리케이션 컨텍스트(Application Context)
	* 빈 팩토리를 확장한 IoC 컨테이너다.
	* 스프링이 제공하는 각종 부가 서비스를 추가로 제공한다.
	* 스프링이 제공하는 애플리케이션 지원 기능을 모두 포함한다.
* 설정정보/설정 메타정보(Configuration metadata)
	* 실제로 스프링의 설정정보는 컨테이너에 어떤 기능을 세팅하거나 조정하는 경우에도 사용하지만, 그보다는 IoC 컨테이너에 의해 관리 되는 애플리케이션 오브젝트를 생성하고 구성할 때 사용된다.
* 컨테이너 or IoC 컨테이너
	* 컨테이너라는 말 자체가 IoC개념을 담고 있다.
	* 스프링 컨테이너라고 불리기도 한다.
	* 애플리케이션 컨텍스트 오브젝트는 하나의 애플리케이션에서 보통 여러 개가 만들어져 사용된다. 이를 통틀어서 스프링 컨테이너라고 부를 수 있다.
* 스프링 프레임워크
	* 스프링이 제공하는 모든 기능을 통틀어 말할 때 주로 사용한다.

## 1.6 싱글톤 레지스트리와 오브젝트 스코프
* 동일성(==) | 동등성(equals())

### 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
* 자바에서 싱글톤을 구현하는 방법
	* 클래스 밖에서는 오브젝트를 생성하지 못하도록 private로 만든다.
	* 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의한다.
	* 스태틱 팩토리 메소드인 getInstance()를 만들고 이 메소드가 최초로 호출되는 시점에서 한 번만 오브젝트가 만들어지게 한다.
	* 한번 오브젝트가 만들어지고 난 후에는 getInstance() 메소드를 통해 이미 만들어져 있는 오브젝트를 넘겨준다.

> 싱글톤 레지스트리
> 	* 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다.
> 	* 장점은 스태틱 메소드와 private 생성자를 사용해야하는 비정상적인 클래스가 아니라 평범한 자바 클래스를 싱글톤으로 활용하게 해준다.
> 	* 평범한 자바 클래스라도 컨테이너에게 넘기면 손쉽게 싱글톤 방식으로 만들어져 관리되게 할 수 있다.

### 1.6.2 싱글톤과 오브젝트의 상태
> 	* 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 **상태정보를 내부에 갖고 있지 않은 무상태방식으로 만들어져야 한다.**
> 	* 파라미터와 로컬변수, 리턴 값 등을 이용하면 무상태 방식으로 만들 수 있다.
> 	* 메소드 안에서 생성되는 로컬 변수는 매번 새로운 값을 저장할 독립적인 공간이 만들어지기 때문에 싱글톤이라고 해도 여러 스레드가 값을 덮어쓸 일은 없다.

### 1.6.3 스프링 빈의 스코프
* 프로토타입은 싱글톤과 싱글톤과 달리 컨테이너에 빈을 요청할 때마다 매번 생성되는 요청 스코프가 있고, 웹의 세션과 스코프가 유사한 세션 스코프도 있다. 스프링에서 만들어지는 빈의 스코프는 싱글톤 외에도 다양한 스코프를 사용할 수 잇다.

## 1.7 의존관계 주입(DI)
### 1.7.1 제어의 역전과 의존관계 주입
> 객체를 생성하고 관계를 맺어주는 등의 작업을 담당하는 기능을 일반화한 것이 스프링의 IoC 컨테이너다.![enter image description here](https://lh3.googleusercontent.com/5fM3HjukIl6Q97FcjR13k7x4yRJZ6clKS1mczqKxx40Uj5tXPhMaKwuOk_n6y7_BJkLc8-kD65c)

* 보통 DI는 그 근간이 되는 개념인 IoC 와 함께 사용해서 IoC/DI 컨테이너라는 식으로 함께 사용하기도 한다.
* DI 컨테이너는 자신이 결정한 의존관계를 맺어줄 클래스의 오브젝트를 만들고 이 생성자의 파라미터로 오브젝트의 레퍼런스를 전달해준다.
* DI는 자신이 사용할 오브젝트에 대한 선택과 생성 제어권을 외부로 넘기고 자신은 수동적으로 주입받은 오브젝트를 사용한다는 점에서 IoC의 개념에 잘 들어맞는다.

### 1.7.3 의존관계 검색과 주입
* 의존관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하기 때문에 의존관계검색이라고 불리는 것도 있다.
* 이런 작업을 일반화한 스프링의 애플리케이션 컨텍스트라면 미리 정해놓은 이름을 전달해서 그 이름에 해당하는 오브젝트를 찾게 된다. 따라서 이를 일종의 검색이라고 볼 수 있다. 또한 그 대상이 런타임 의존관계를 가질 오브젝트이므로 의존관계 검색이라고 부르는 것이다.
* 의존관계 검색 방식에서는 검색하는 오브젝트는 자신이 스프링의 빈일 필요가 없다는 점이다.
* 의존관계 주입에서 UserDao와 ConnectionMaker 사이에 DI가 적영되려면 UserDao도 반드시 컨테이너가 만드는 빈 오브젝트여야 한다.
* DI를 원하는 오브젝트는 먼저 자기 자신이 컨테이너가 관리하는 빈이 돼야한다.
